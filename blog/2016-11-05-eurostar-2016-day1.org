#+TITLE: EuroSTAR Conference 2016 - day 1 summary
#+DATE: 2016-10-31
#+SETUPFILE: ~/code/org-style/setupfile.org
#+JEKYLL_LAYOUT: post
#+JEKYLL_CATEGORIES: EuroSTAR, Conference, Testing
#+JEKYLL_TAGS: EuroSTAR, Conference, 2016, Testing
#+JEKYLL_PUBLISHED: true
#+JEKYLL_COMMENTS: true

* EuroSTAR Conference 2016 - First Day Summary
The First day was honored to the topic of testing with
variables. Thank you ... for the notes you gave us and showed us on
how to test by variables while also finding out about the subjects on
how to generate these variables and use them.

* Notes from "Testing with variables" by Dale Emery taken by Martin 'golodhrim' Scholz
** Variables and Testing
First identify your variables that could be changed and select the
needed ones. But be aware, there will always be variables you are not
aware of and that can influence a lot in the end.
The first question we need to ask is: "What is a variable?"
- Variable :: Anything whose value can be changed
After all there is not only one type of variables, there are at all
three:
- _obvious_, like a field on a form,
- _hidden_, like an internal value or
- _subtle_, like the state of a control
Testing here involves choosing values for every variable (not just the
obvious ones).

- A Subtle Variable ::
In January 2004, Nasa lost contact with the Mars Rover Spirit.

They soon discovered that the Spirit had encountered a serious anomaly
and was rebooting itself over and over again.

According to an article on the site Spaceflight Now, the Mars Rover problem was that there were *too many files on the flash memory*.

- Available Disk Space on Install ::
#+BEGIN_SRC dot :file ../blogimages/space-prog.png :exports results
  digraph graphname {
    U [label="User", shape=box, style=filled, color=blue]
    I [label="Installer", style=filled, color=yellow]
    O [label="OS", style=filled, color=yellow]

    U->I [label="Start Install"]
    I->O [label="How much space is available?"]
    O->I [label="47744851968 bytes"]
    I->U [label="-1647271925 bytes is not enough"]
  }
#+END_SRC

#+RESULTS:
[[file:../blogimages/space-prog.png]]

To make sure you identified a variable right, try this tip:

#+BEGIN_QUOTE
I could vary <VARIABLENAME>.

(<N>) possible values for <VARIABLENAME> are <VAR1>, <VAR2>, ... and <VARn>.
#+END_QUOTE

** Testing is an Information Service
#+BEGIN_QUOTE
Testing is a process of gathering informatiion by making observations
and comparing them to expectations.

Information reduces uncertainty. Decision makers use this information
to move the project forward.

We have a responsibility to provide those decision makers with the
best information we can.
#+END_QUOTE

First explore for that who are your *stakeholders*. If you know who
they will be, try to gather the questions they want to be answered
about the software and what you can do to discover the information
that will cover them. Now it is time on how to provide the
information.

For that we need to move from variables to tests.
1. Identify stakeholders' needs
2. Brainstorm variables for it
3. Select a variable to explore
4. Select a value to try and
5. run it.

** How is a Test Case Build?
Elements of a Test Case are:
#+BEGIN_SRC dot :file ../blogimages/tcelements.png :exports results
  digraph graphname {
    rankdir="LR"

    S [label="Setup"]
    A [label="Action(s)"]
    E [label="Expectations"]

    S -> A;
    A -> E;
  }
#+END_SRC

#+RESULTS:
[[file:../blogimages/tcelements.png]]

But WHY should we consider so many variables?

Simply just imagine a program that converts binary numbers to decimal.

| Input | Expected | Actual Result | Test Result |
|-------+----------+---------------+-------------|
|   000 |        0 |             0 | OK          |
|   111 |        7 |             7 | OK          |
|   101 |        5 |             5 | OK          |
|   011 |        3 |             6 | nOK         |

Analyzing Variables Helps Avoid the Problem of Incidental Correctness.

So at that point you should build a catalog of generic tests, they
will serve you as tests for various types of variables:
- Text/Strings
- Paths
- Numbers
- Dates
- Windows
- Option settings
- etc.

** Variables and Models
#+BEGIN_QUOTE
Testing fom existing models

Testing by creating models

Models of sytem structure

Models of system behavior
#+END_QUOTE

*** Two views of a System: Dynamic and Static...
- Dynamic models :: such as state models or flow charts show how the
     system behaves.
- Static models :: such as entity-relationship diagrams show the
     structure of the system.

So both totally different types of models, are giving us different
views into the system.

#+BEGIN_SRC dot :file ../blogimages/simplestmodel.png :exports results
    digraph graphname {
      rankdir="LR"

      "On" -> "Off" [label="Start"];
      "Off" -> "On" [label="Stop"];
    }
#+END_SRC

#+RESULTS:
[[file:../blogimages/simplestmodel.png]]

On/Off are called States, Start/Stop are events and the change of
states by an event are called a transition.

These simple example could be extended pretty easy to something more
complex but still simple:

#+BEGIN_SRC dot :file ../blogimages/modeltwo.png :exports results
  digraph graphname {
    rankdir="LR"

    "Off" -> "Cool" [label="Temp >\nSetting"];
    "Cool" -> "Off" [label="Temp <=\nSetting"];
    "Off" -> "Heat" [label="Temp <\nSetting"];
    "Heat" -> "Off" [label="Temp >=\nSetting"];
  }
#+END_SRC

#+RESULTS:
[[file:../blogimages/modeltwo.png]]

These easy examples could now lead us to an easy testing model:

#+BEGIN_SRC dot :file ../blogimages/displaymodemodel.png :exports results
  digraph graphname {
    rankdir="LR"
    W [label="White Screen"]
    S [label="Slideshow"]
    B [label="Black Screen"]

    W -> S [label="any key pressed"];
    S -> W [label="W pressed"];
    B -> S [label="any key pressed"];
    S -> B [label="B pressed"];
  }
#+END_SRC

#+RESULTS:
[[file:../blogimages/displaymodemodel.png]]

Aboves diagram leads to the following Table:

|           | Slideshow | White | Black |
|-----------+-----------+-------+-------|
| Slideshow | N/A       | "W"   | "B"   |
|-----------+-----------+-------+-------|
| White     | Any Key   | N/A   | N/A   |
|-----------+-----------+-------+-------|
| Black     | Any Key   | N/A   | N/A   |

This table shows us that we don't know about keys that could also be
used in the Pr√§sentation mode, or how we could transition from Black
to White with one key.

*** Testing from State Models
When testing from State Models, think about the following:
1. _Transitions_
   - Do all the events trigger the transitions we expect?
     Test every path.
   - What happens if we repeat loops
     (submit-cancel-submit-cancel-repeat)? Check for memory leaks or
     data corruption.
2. _Interruptions_
  - What happens if we force an exit from intermediate states?
  - What happens if we trigger events when they aren't expected?

*** Exercise: Modeling States
1. Form teams
2. Create a model of the states that a *bug* goes through in your bug
   tracking system.
3. Use your model to identify variables to vary
4. Design tests from your state model. Think about the various test
   types listed on the previous page.
5. Prepare to share your model and tests with the other teams.

*** TODO Insert the graphic!

|           | REPORT | REJECT   | APPROVE  | REVIEW   | ASSIGN   | RESOLVE  | TESTFW    | CLOSE  | REOPEN    | RESUBMIT  | WAIT    |
|-----------+--------+----------+----------+----------+----------+----------+-----------+--------+-----------+-----------+---------|
| SUBMITTED | x      | -        | -        | REVIEWED | -        | -        | -         | -      | -         | -         | ON HOLD |
| REJECTED  | -      | -        | -        | -        | -        | -        | -         | CLOSED | -         | SUBMITTED | -       |
| VALIDATED | -      | -        | -        | -        | ASSIGNED | -        | -         | -      | -         | -         | ON HOLD |
| ON HOLD   | -      | -        | APPROVED | -        | -        | -        | TESTED/QA | -      | -         | -         | -       |
| RESOLVED  | -      | -        | -        | -        | -        | -        | TESTED/QA | -      | -         | -         | ON HOLD |
| TESTED/QA | -      | -        | -        | -        | -        | -        | -         | CLOSED | -         | -         | ON HOLD |
| CLOSED    | -      | -        | -        | -        | -        | -        | -         | -      | SUBMITTED | -         | -       |
| REVIEWED  | -      | REJECTED | APPROVED | -        | -        | -        | -         | -      | -         | -         | ON HOLD |
| ASSIGNED  | -      | -        | -        | -        | -        | RESOLVED | -         | -      | -         | -         | ON HOLD |


{{{more}}}
